# SCC Vulnerability Ingestion Service

Automated service for ingesting vulnerability findings from GCP Security Command Center (SCC) API v2 with support for Firestore and Redis datastores.

> **Note**: This service uses Security Command Center API v2. The v1 API has been deprecated as of November 2025.

## Features

- **Efficient Batch Processing**: Handles 60k+ vulnerability findings efficiently
- **Dual Datastore Support**: Choose between Firestore or Redis
- **Data Enrichment**: Automatically enriches vulnerabilities with appcode and LOB
- **Atomic Operations**: Ensures data consistency with upsert operations
- **Parallel Processing**: Configurable parallel workers for optimal performance
- **Cron Job Ready**: Designed to run as a scheduled Cloud Run job

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    SCC INGESTION FLOW                        │
└─────────────────────────────────────────────────────────────┘

1. Fetch Findings
   ┌──────────────┐
   │ Cloud        │
   │ Scheduler    │──────► Trigger every 6 hours
   └──────┬───────┘
          │
          ▼
   ┌──────────────┐
   │  SCC Client  │──────► Fetch vulnerability findings
   │              │        (60k+ findings)
   └──────┬───────┘
          │
          ▼
2. Load Mapping
   ┌──────────────┐
   │  Datastore   │──────► Load project mapping
   │  (Firestore/ │        {projectid: {appcode, lob}}
   │   Redis)     │
   └──────┬───────┘
          │
          ▼
3. Enrich Data
   ┌──────────────┐
   │  Ingestion   │──────► Enrich findings with
   │  Service     │        appcode & lob
   └──────┬───────┘
          │
          ▼
4. Batch Upsert
   ┌──────────────┐
   │  Datastore   │──────► Atomic batch upsert
   │  (500/batch) │        (Firestore: 500, Redis: 1000)
   └──────────────┘
```

## Files Created

```
scc-vulnerability-ingestion/
├── config.py                      # Configuration management
├── .env.dev                       # Development environment
├── firestore_datastore.py         # Firestore implementation
├── redis_datastore.py             # Redis implementation
├── datastore_factory.py           # Factory for datastore creation
├── scc_client.py                  # SCC API client
├── ingestion_service.py           # Main ingestion logic
├── main.py                        # Entry point
├── requirements.txt               # Python dependencies
├── Dockerfile                     # Container image
├── cloud_scheduler.yaml           # Scheduler configuration
├── deploy.sh                      # Deployment script
├── setup_project_mapping.py       # Helper for project mapping
├── project_mapping_sample.csv     # Sample data
├── README.md                      # Comprehensive documentation
└── QUICKSTART.md                  # Quick start guide
```

## Data Flow

### Input: SCC Findings
```json
{
  "finding_name": "organizations/123/sources/456/findings/789",
  "category": "VULNERABILITY",
  "severity": "HIGH",
  "resource_name": "//compute.googleapis.com/projects/my-project/...",
  "cve": "CVE-2023-1234",
  "cvss_score": 7.5
}
```

### Project Mapping (Firestore/Redis)
```json
{
  "projectid": "my-project-123",
  "appcode": "payment-service",
  "lob": "finance"
}
```

### Output: Enriched Vulnerability
```json
{
  "finding_id": "789",
  "finding_name": "organizations/123/sources/456/findings/789",
  "category": "VULNERABILITY",
  "state": "ACTIVE",
  "severity": "HIGH",
  "resource_name": "//compute.googleapis.com/projects/my-project/...",
  "resource_type": "google.compute.Instance",
  "project_id": "my-project-123",
  "appcode": "payment-service",
  "lob": "finance",
  "cve": "CVE-2023-1234",
  "cvss_score": 7.5,
  "create_time": "2025-10-30T12:00:00Z",
  "event_time": "2025-10-30T12:00:00Z",
  "last_seen": "2025-10-31T05:12:00Z"
}
```

## Configuration

### Environment Variables

**.env.dev:**
```bash
# GCP Configuration
GCP_PROJECT_ID=evol-dev-456410
GCP_ORGANIZATION_ID=922071633244

# Firestore Configuration - Vulnerability Database
FIRESTORE_VULNERABILITY_DB=(default)
FIRESTORE_COLLECTION_VULNERABILITIES=scc-vulnerabilities-dev

# Firestore Configuration - Inventory Database (for project mapping)
FIRESTORE_INVENTORY_DB=(default)
FIRESTORE_INVENTORY_COLLECTION=project-mapping-dev
FIRESTORE_INVENTORY_FIELD_PROJECT_ID=project_id
FIRESTORE_INVENTORY_FIELD_APPCODE=appcode
FIRESTORE_INVENTORY_FIELD_LOB=lob

# Batch Processing
BATCH_SIZE=500
MAX_WORKERS=10

# SCC Configuration
# API v2 uses 'category' instead of 'findingClass'
SCC_FINDING_FILTER=state="ACTIVE" AND category="VULNERABILITY"
SCC_PAGE_SIZE=1000

# Logging
LOG_LEVEL=INFO
```

### Configuration Details

#### **Vulnerability Database**
- `FIRESTORE_VULNERABILITY_DB`: Database name for storing vulnerabilities (use `(default)` for default database)
- `FIRESTORE_COLLECTION_VULNERABILITIES`: Collection name for vulnerability documents

#### **Inventory Database**
The inventory database stores project metadata (appcode, LOB) and can be a separate database from vulnerabilities.

- `FIRESTORE_INVENTORY_DB`: Database name for inventory (use `(default)` for default database)
- `FIRESTORE_INVENTORY_COLLECTION`: Collection name for project mapping documents
- `FIRESTORE_INVENTORY_FIELD_PROJECT_ID`: Field name for project ID (default: `project_id`)
- `FIRESTORE_INVENTORY_FIELD_APPCODE`: Field name for application code (default: `appcode`)
- `FIRESTORE_INVENTORY_FIELD_LOB`: Field name for line of business (default: `lob`)

**Example: Separate Databases**
```bash
# Vulnerabilities in default database
FIRESTORE_VULNERABILITY_DB=(default)
FIRESTORE_COLLECTION_VULNERABILITIES=scc-vulnerabilities

# Inventory in separate database
FIRESTORE_INVENTORY_DB=inventory-db
FIRESTORE_INVENTORY_COLLECTION=projects
FIRESTORE_INVENTORY_FIELD_PROJECT_ID=projectId
FIRESTORE_INVENTORY_FIELD_APPCODE=applicationCode
FIRESTORE_INVENTORY_FIELD_LOB=lineOfBusiness
```

**Example: Same Database, Different Collections**
```bash
# Both in default database
FIRESTORE_VULNERABILITY_DB=(default)
FIRESTORE_COLLECTION_VULNERABILITIES=vulnerabilities

FIRESTORE_INVENTORY_DB=(default)
FIRESTORE_INVENTORY_COLLECTION=project-inventory
```

## Datastore Options

### Option 1: Firestore

**Pros:**
- Native GCP integration
- Automatic scaling
- Strong consistency
- Rich querying capabilities
- No infrastructure management

**Cons:**
- Higher latency for reads
- Cost per operation
- 500 operations per batch limit

**Configuration:**
```bash
DATASTORE_TYPE=firestore
FIRESTORE_COLLECTION_VULNERABILITIES=scc-vulnerabilities
FIRESTORE_COLLECTION_PROJECT_MAPPING=project-mapping
```

**Atomicity:**
- Uses Firestore batch writes (max 500 operations)
- All operations in a batch succeed or fail together
- Uses finding_id as document ID for automatic upsert

### Option 2: Redis

**Pros:**
- Ultra-fast reads/writes
- Lower latency
- Higher throughput
- Cost-effective for large datasets
- TTL support for automatic cleanup

**Cons:**
- Requires Redis instance management
- Memory-based (cost scales with data size)
- Less rich querying

**Configuration:**
```bash
DATASTORE_TYPE=redis
REDIS_HOST=10.0.0.1
REDIS_PORT=6379
REDIS_KEY_PREFIX=scc:vuln:
REDIS_KEY_TTL=86400
```

**Atomicity:**
- Uses Redis pipelines for atomic batch operations
- All commands in pipeline execute atomically
- Uses finding_id as key for automatic upsert
- `SET` with `EX` for TTL support

## Performance Optimization

### Streaming Architecture

**Memory-Efficient Design:**
- Streams findings from SCC without loading all into memory
- Processes batches dynamically as they're fetched
- Suitable for Cloud Run with limited memory (512MB-1GB)
- Can handle 100k+ findings without memory issues

**How It Works:**
```
SCC API (async stream)
    ↓
Fetch Finding → Add to Batch
    ↓
Batch Full? → Schedule Processing Task
    ↓
Continue Fetching (non-blocking)
    ↓
Process Multiple Batches in Parallel
    ↓
Wait for Completion
```

**Benefits:**
- Constant memory usage regardless of dataset size
- Parallel processing while streaming
- No memory spikes from loading all findings
- Optimal for Cloud Run constraints

### Batch Processing

**Firestore:**
- Batch size: 500 (Firestore limit)
- Processes 60,000 findings in ~120 batches
- Estimated time: 2-5 minutes
- Memory usage: ~50-100MB (streaming)

### Parallel Processing

```python
# Sequential processing
await service.ingest_vulnerabilities()

# Parallel processing (recommended for 60k+ rows)
await service.ingest_vulnerabilities_parallel()
```

**Configuration:**
```bash
MAX_WORKERS=10  # Number of parallel workers
BATCH_SIZE=500  # Findings per batch
```

**Performance:**
- 60,000 findings with 10 workers
- Throughput: ~500-1000 records/second
- Total time: 60-120 seconds

## Setup Project Mapping

### Firestore

Create documents in `project-mapping` collection:

```python
from google.cloud import firestore

db = firestore.Client()
collection = db.collection('project-mapping-dev')

# Add project mappings
collection.document('project-1').set({
    'projectid': 'my-project-123',
    'appcode': 'payment-service',
    'lob': 'finance'
})

collection.document('project-2').set({
    'projectid': 'analytics-456',
    'appcode': 'analytics-platform',
    'lob': 'data'
})
```

### Redis

Use the helper method or Redis CLI:

```python
from redis_datastore import RedisDatastore

datastore = RedisDatastore()
await datastore.set_project_mapping('my-project-123', 'payment-service', 'finance')
await datastore.set_project_mapping('analytics-456', 'analytics-platform', 'data')
```

Or via Redis CLI:
```bash
redis-cli HSET scc:vuln:dev:project_mapping my-project-123 '{"appcode":"payment-service","lob":"finance"}'
```

## Deployment

### Local Testing

```bash
# Install dependencies
pip install -r requirements.txt

# Set environment
export ENVIRONMENT=dev

# Run ingestion
python main.py
```

### Cloud Run Deployment

**1. Build and push Docker image:**
```bash
gcloud builds submit --tag gcr.io/PROJECT_ID/scc-ingestion:latest
```

**2. Deploy to Cloud Run:**
```bash
gcloud run deploy scc-ingestion \
  --image gcr.io/PROJECT_ID/scc-ingestion:latest \
  --platform managed \
  --region asia-southeast1 \
  --memory 2Gi \
  --timeout 1800 \
  --set-env-vars ENVIRONMENT=prod \
  --service-account scc-ingestion@PROJECT_ID.iam.gserviceaccount.com \
  --no-allow-unauthenticated
```

**3. Create Cloud Scheduler job:**
```bash
gcloud scheduler jobs create http scc-vulnerability-ingestion \
  --schedule="0 */6 * * *" \
  --uri="https://scc-ingestion-SERVICE_URL/run" \
  --http-method=POST \
  --oidc-service-account-email=scc-ingestion@PROJECT_ID.iam.gserviceaccount.com \
  --location=asia-southeast1 \
  --time-zone="Asia/Singapore"
```

### IAM Permissions

**Service Account:** `scc-ingestion@PROJECT_ID.iam.gserviceaccount.com`

**Required Roles:**
```bash
# Security Command Center
roles/securitycenter.findingsViewer

# Firestore (if using Firestore)
roles/datastore.user

# Cloud Run
roles/run.invoker
```

**Grant permissions:**
```bash
# SCC permissions
gcloud organizations add-iam-policy-binding ORG_ID \
  --member="serviceAccount:scc-ingestion@PROJECT_ID.iam.gserviceaccount.com" \
  --role="roles/securitycenter.findingsViewer"

# Firestore permissions
gcloud projects add-iam-policy-binding PROJECT_ID \
  --member="serviceAccount:scc-ingestion@PROJECT_ID.iam.gserviceaccount.com" \
  --role="roles/datastore.user"
```

## Usage Examples

### Run Ingestion Job

```python
import asyncio
from datastore_factory import create_datastore
from ingestion_service import IngestionService

async def run_ingestion():
    datastore = create_datastore()
    service = IngestionService(datastore)
    
    # Run parallel ingestion
    stats = await service.ingest_vulnerabilities_parallel()
    
    print(f"Fetched: {stats['total_fetched']}")
    print(f"Upserted: {stats['total_upserted']}")
    
    await datastore.close()

asyncio.run(run_ingestion())
```

### Query Vulnerabilities

**Firestore:**
```python
from google.cloud import firestore

db = firestore.Client()

# Get all HIGH severity vulnerabilities
vulns = db.collection('scc-vulnerabilities') \
    .where('severity', '==', 'HIGH') \
    .where('state', '==', 'ACTIVE') \
    .stream()

for vuln in vulns:
    data = vuln.to_dict()
    print(f"{data['cve']}: {data['appcode']} - {data['lob']}")
```

**Redis:**
```python
import redis
import json

r = redis.Redis(host='localhost', port=6379, db=0)

# Get vulnerability by finding ID
key = 'scc:vuln:dev:finding-123'
data = r.get(key)
if data:
    vuln = json.loads(data)
    print(f"{vuln['cve']}: {vuln['appcode']} - {vuln['lob']}")
```

## Monitoring

### Logs

```bash
# View Cloud Run logs
gcloud logging read "resource.type=cloud_run_revision AND resource.labels.service_name=scc-ingestion" \
  --limit 50 \
  --format json

# View local logs
tail -f ingestion_*.log
```

### Metrics

**Key Metrics:**
- Total findings fetched
- Total vulnerabilities upserted
- Processing duration
- Throughput (records/second)
- Batch processing time

**Example Output:**
```
================================================================================
SCC Vulnerability Ingestion Job Completed
End Time: 2025-10-31T10:30:00
Duration: 95.23 seconds
Findings Fetched: 62,450
Vulnerabilities Upserted: 62,450
Projects Mapped: 1,234
Batches Processed: 125
Throughput: 655.78 records/second
Datastore Stats: {'datastore_type': 'firestore', 'total_vulnerabilities': 62450}
================================================================================
```

## Troubleshooting

### Issue: Slow Performance

**Solution:**
- Increase `MAX_WORKERS` (default: 10)
- Increase `BATCH_SIZE` (Firestore: max 500, Redis: 1000+)
- Use Redis for faster writes
- Use parallel ingestion mode

### Issue: Memory Errors

**Solution:**
- Decrease `BATCH_SIZE`
- Decrease `MAX_WORKERS`
- Increase Cloud Run memory allocation
- Use sequential ingestion mode

### Issue: Missing Appcode/LOB

**Solution:**
- Verify project mapping exists in datastore
- Check project ID extraction from resource name
- Review logs for mapping warnings

### Issue: Duplicate Data

**Solution:**
- Upsert operations prevent duplicates
- Firestore: Uses `finding_id` as document ID
- Redis: Uses `finding_id` in key name
- Both ensure atomicity

## Cost Optimization

### Firestore
- Use TTL policies for old data
- Index only necessary fields
- Monitor read/write operations

### Redis
- Set appropriate TTL (default: 24 hours)
- Use Redis Memorystore (managed)
- Monitor memory usage

### Cloud Run
- Set appropriate memory limits
- Use minimum CPU allocation
- Schedule during off-peak hours

## Best Practices

1. **Run during off-peak hours** (e.g., every 6 hours)
2. **Monitor ingestion duration** and adjust batch size
3. **Set up alerting** for failed ingestion jobs
4. **Regularly review** project mappings
5. **Archive old vulnerabilities** to reduce datastore size
6. **Use Redis for high-throughput** scenarios
7. **Use Firestore for rich querying** requirements

## API v2 Migration

### What Changed

**API v1 (Deprecated):**
```python
from google.cloud import securitycenter
client = securitycenter.SecurityCenterClient()
parent = f"organizations/{org_id}/sources/-"
```

**API v2 (Current):**
```python
from google.cloud.securitycenter_v2 import SecurityCenterClient
client = SecurityCenterClient()
parent = f"organizations/{org_id}/sources/-"
```

### Key Differences

1. **Parent Format**: Remains `organizations/{org}/sources/-` (same as v1)
2. **No Location Suffix**: Do NOT add `/locations/-` to the parent path
3. **Package Import**: Use `google.cloud.securitycenter_v2` instead of `google.cloud.securitycenter`
4. **Library Version**: Requires `google-cloud-securitycenter>=1.35.0`
5. **Filter Syntax**: Use `category` instead of `findingClass` in filters
6. **Source ID**: Must be numeric (1-20 chars) or use `-` for all sources

### Upgrade Steps

1. **Update dependencies:**
   ```bash
   pip install --upgrade google-cloud-securitycenter>=1.35.0
   ```

2. **Update code imports:**
   ```python
   # Old
   from google.cloud import securitycenter
   
   # New
   from google.cloud.securitycenter_v2 import SecurityCenterClient
   from google.cloud.securitycenter_v2.types import ListFindingsRequest
   ```

3. **Parent path (unchanged):**
   ```python
   # Both v1 and v2 use the same format
   parent = f"organizations/{org_id}/sources/-"
   
   # Note: Do NOT add /locations/- suffix in v2
   ```

4. **Update filter syntax:**
   ```python
   # Old (v1)
   SCC_FINDING_FILTER = 'state="ACTIVE" AND findingClass="VULNERABILITY"'
   
   # New (v2)
   SCC_FINDING_FILTER = 'state="ACTIVE" AND category="VULNERABILITY"'
   ```

5. **Test the migration:**
   ```bash
   python main.py
   ```

### Filter Syntax Changes

**API v1 → v2 Field Mapping:**

| v1 Field | v2 Field | Example |
|----------|----------|---------|
| `findingClass` | `category` | `category="VULNERABILITY"` |
| `state` | `state` | `state="ACTIVE"` (unchanged) |
| `severity` | `severity` | `severity="HIGH"` (unchanged) |

**Common Filters (v2):**

```python
# All active vulnerabilities
'state="ACTIVE" AND category="VULNERABILITY"'

# Software vulnerabilities only
'state="ACTIVE" AND category="VULNERABILITY" AND finding_class="VULNERABILITY"'

# Critical/High severity
'state="ACTIVE" AND severity IN ("CRITICAL", "HIGH")'

# Specific resource type
'state="ACTIVE" AND resource.type="google.compute.Instance"'

# Combination
'state="ACTIVE" AND category="VULNERABILITY" AND severity="CRITICAL"'
```

### Compatibility

- **Minimum Version**: `google-cloud-securitycenter==1.35.0`
- **Python**: 3.8+
- **API**: Security Command Center API v2

## License

Internal use only.
