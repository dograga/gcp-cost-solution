"""Firestore datastore for SCC vulnerability ingestion"""

from typing import List, Dict, Any, Optional
import logging
from google.cloud import firestore
import config

logger = logging.getLogger(__name__)


class Datastore:
    """Firestore implementation with batch operations and atomicity"""
    
    def __init__(self):
        # Vulnerability database client
        vuln_db_name = config.FIRESTORE_VULNERABILITY_DB
        if vuln_db_name == '(default)':
            self.vuln_db = firestore.Client(project=config.GCP_PROJECT_ID)
        else:
            self.vuln_db = firestore.Client(project=config.GCP_PROJECT_ID, database=vuln_db_name)
        
        # Inventory database client (may be different database)
        inventory_db_name = config.FIRESTORE_INVENTORY_DB
        if inventory_db_name == '(default)':
            self.inventory_db = firestore.Client(project=config.GCP_PROJECT_ID)
        else:
            self.inventory_db = firestore.Client(project=config.GCP_PROJECT_ID, database=inventory_db_name)
        
        self.vuln_collection = config.FIRESTORE_COLLECTION_VULNERABILITIES
        self.inventory_collection = config.FIRESTORE_INVENTORY_COLLECTION
        self.inventory_field_project_id = config.FIRESTORE_INVENTORY_FIELD_PROJECT_ID
        self.inventory_field_appcode = config.FIRESTORE_INVENTORY_FIELD_APPCODE
        self.inventory_field_lob = config.FIRESTORE_INVENTORY_FIELD_LOB
        
        logger.info(f"Initialized Firestore datastore:")
        logger.info(f"  Vulnerability DB: {vuln_db_name}, Collection: {self.vuln_collection}")
        logger.info(f"  Inventory DB: {inventory_db_name}, Collection: {self.inventory_collection}")
    
    async def upsert_vulnerabilities(self, vulnerabilities: List[Dict[str, Any]]) -> int:
        """
        Insert vulnerabilities using Firestore batch operations.
        Using finding_id as document ID automatically handles upsert.
        Firestore supports max 500 operations per batch.
        """
        if not vulnerabilities:
            return 0
        
        total_upserted = 0
        batch_size = 500  # Firestore limit
        
        for i in range(0, len(vulnerabilities), batch_size):
            batch_vulnerabilities = vulnerabilities[i:i + batch_size]
            
            # Use batch write for atomicity
            batch = self.vuln_db.batch()
            
            for vuln in batch_vulnerabilities:
                finding_id = vuln.get('finding_id')
                if not finding_id:
                    logger.warning(f"Skipping vulnerability without finding_id: {vuln}")
                    continue
                
                # Use finding_id as document ID - this automatically upserts
                doc_ref = self.vuln_db.collection(self.vuln_collection).document(finding_id)
                batch.set(doc_ref, vuln)
                total_upserted += 1
            
            # Commit batch atomically
            try:
                batch.commit()
                logger.info(f"Committed batch of {len(batch_vulnerabilities)} vulnerabilities")
            except Exception as e:
                logger.error(f"Error committing batch: {e}")
                raise
        
        return total_upserted
    
    async def get_project_mapping(self) -> Dict[str, Dict[str, str]]:
        """
        Get project mapping from inventory database.
        Uses configurable field names for project_id, appcode, and lob.
        """
        mapping = {}
        
        try:
            docs = self.inventory_db.collection(self.inventory_collection).stream()
            
            for doc in docs:
                data = doc.to_dict()
                project_id = data.get(self.inventory_field_project_id)
                appcode = data.get(self.inventory_field_appcode)
                lob = data.get(self.inventory_field_lob)
                
                if project_id:
                    mapping[project_id] = {
                        'appcode': appcode or 'unknown',
                        'lob': lob or 'unknown'
                    }
            
            logger.info(f"Loaded {len(mapping)} project mappings from inventory database")
            return mapping
            
        except Exception as e:
            logger.error(f"Error loading project mapping from inventory database: {e}")
            return {}
    
    async def get_vulnerability(self, finding_id: str) -> Optional[Dict[str, Any]]:
        """Get a single vulnerability by finding ID"""
        try:
            doc_ref = self.vuln_db.collection(self.vuln_collection).document(finding_id)
            doc = doc_ref.get()
            
            if doc.exists:
                return doc.to_dict()
            return None
            
        except Exception as e:
            logger.error(f"Error getting vulnerability {finding_id}: {e}")
            return None
    
    async def delete_vulnerability(self, finding_id: str) -> bool:
        """Delete a vulnerability by finding ID"""
        try:
            doc_ref = self.vuln_db.collection(self.vuln_collection).document(finding_id)
            doc_ref.delete()
            logger.info(f"Deleted vulnerability: {finding_id}")
            return True
            
        except Exception as e:
            logger.error(f"Error deleting vulnerability {finding_id}: {e}")
            return False
    
    async def get_statistics(self) -> Dict[str, Any]:
        """Get Firestore statistics"""
        try:
            # Count documents (expensive for large collections)
            docs = self.vuln_db.collection(self.vuln_collection).stream()
            count = sum(1 for _ in docs)
            
            return {
                'datastore_type': 'firestore',
                'collection': self.vuln_collection,
                'total_vulnerabilities': count
            }
            
        except Exception as e:
            logger.error(f"Error getting statistics: {e}")
            return {
                'datastore_type': 'firestore',
                'error': str(e)
            }
    
    async def close(self):
        """Close Firestore connections"""
        # Firestore client doesn't require explicit closing
        logger.info("Firestore datastore closed")
