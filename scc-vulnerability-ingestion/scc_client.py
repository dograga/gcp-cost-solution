"""Client for fetching vulnerability findings from GCP Security Command Center"""

import logging
import asyncio
from typing import Dict, Any, AsyncIterator
from google.cloud.securitycenter_v2 import SecurityCenterClient
from google.cloud.securitycenter_v2.types import ListFindingsRequest
import config

logger = logging.getLogger(__name__)


class SCCClient:
    """Client for interacting with GCP Security Command Center API v2"""
    
    def __init__(self):
        self.client = SecurityCenterClient()
        self.org_name = f"organizations/{config.GCP_ORGANIZATION_ID}"
        logger.info(f"Initialized SCC v2 client for organization: {self.org_name}")
    
    async def fetch_vulnerability_findings(self) -> AsyncIterator[Dict[str, Any]]:
        """
        Fetch vulnerability findings from SCC v2 asynchronously.
        Yields findings one at a time for memory efficiency.
        
        Yields:
            Dictionary containing finding data
        """
        # API v2 uses parent format: organizations/{org}/sources/{source}/locations/{location}
        # Use "-" for source and location to search across all
        parent = f"{self.org_name}/sources/-/locations/-"
        
        request = ListFindingsRequest(
            parent=parent,
            filter=config.SCC_FINDING_FILTER,
            page_size=config.SCC_PAGE_SIZE
        )
        
        logger.info(f"Fetching findings from parent: {parent}")
        logger.info(f"Using filter: {config.SCC_FINDING_FILTER}")
        logger.info(f"Page size: {config.SCC_PAGE_SIZE}")
        
        try:
            # Run the synchronous API call in executor to avoid blocking
            loop = asyncio.get_event_loop()
            findings_iterator = await loop.run_in_executor(
                None, 
                self.client.list_findings, 
                request
            )
            
            count = 0
            # Convert synchronous iterator to async iterator
            for finding_result in findings_iterator:
                finding = finding_result.finding
                resource = finding_result.resource
                
                # Extract relevant data
                finding_data = self._extract_finding_data(finding, resource)
                
                count += 1
                if count % 1000 == 0:
                    logger.info(f"Fetched {count} findings from SCC...")
                
                # Yield control back to event loop periodically
                if count % 100 == 0:
                    await asyncio.sleep(0)
                
                yield finding_data
            
            logger.info(f"Total findings fetched: {count}")
            
        except Exception as e:
            logger.error(f"Error fetching findings from SCC: {e}")
            raise
    
    def _extract_finding_data(self, finding, resource) -> Dict[str, Any]:
        """
        Extract and structure finding data with comprehensive vulnerability details.
        
        Args:
            finding: SCC Finding object
            resource: SCC Resource object
            
        Returns:
            Dictionary with structured finding data
        """
        # Extract project ID from resource name
        # Format: //cloudresourcemanager.googleapis.com/projects/123456
        project_id = None
        if resource.name:
            parts = resource.name.split('/')
            if 'projects' in parts:
                idx = parts.index('projects')
                if idx + 1 < len(parts):
                    project_id = parts[idx + 1]
        
        # Extract vulnerability details
        vulnerability = finding.vulnerability if hasattr(finding, 'vulnerability') else None
        
        # Initialize vulnerability fields
        cve_id = None
        cve_references = []
        cvssv3_data = None
        zero_day = None
        impact = None
        exploitation_activity = None
        exploit_release_date = None
        first_exploitation_date = None
        offending_package = None
        fixed_package = None
        
        if vulnerability:
            # CVE details
            if hasattr(vulnerability, 'cve') and vulnerability.cve:
                cve_id = vulnerability.cve.id if hasattr(vulnerability.cve, 'id') else None
                
                # CVE references
                if hasattr(vulnerability.cve, 'references'):
                    cve_references = [ref.uri if hasattr(ref, 'uri') else str(ref) 
                                     for ref in vulnerability.cve.references]
                
                # CVSS v3 details
                if hasattr(vulnerability.cve, 'cvssv3'):
                    cvssv3 = vulnerability.cve.cvssv3
                    cvssv3_data = {
                        'base_score': cvssv3.baseScore if hasattr(cvssv3, 'baseScore') else None,
                        'attack_vector': cvssv3.attackVector if hasattr(cvssv3, 'attackVector') else None,
                        'attack_complexity': cvssv3.attackComplexity if hasattr(cvssv3, 'attackComplexity') else None,
                        'privileges_required': cvssv3.privilegesRequired if hasattr(cvssv3, 'privilegesRequired') else None,
                        'user_interaction': cvssv3.userInteraction if hasattr(cvssv3, 'userInteraction') else None,
                        'scope': cvssv3.scope if hasattr(cvssv3, 'scope') else None,
                        'confidentiality_impact': cvssv3.confidentialityImpact if hasattr(cvssv3, 'confidentialityImpact') else None,
                        'integrity_impact': cvssv3.integrityImpact if hasattr(cvssv3, 'integrityImpact') else None,
                        'availability_impact': cvssv3.availabilityImpact if hasattr(cvssv3, 'availabilityImpact') else None
                    }
            
            # Zero day indicator
            if hasattr(vulnerability.cve, 'zeroDay'):
                zero_day = vulnerability.cve.zeroDay
            
            # Impact description
            if hasattr(vulnerability.cve, 'impact'):
                impact = vulnerability.cve.impact
            
            # Exploitation activity
            if hasattr(vulnerability.cve, 'exploitationActivity'):
                exploitation_activity = vulnerability.cve.exploitationActivity
            
            # Exploit dates
            if hasattr(vulnerability.cve, 'exploitReleaseDate'):
                exploit_release_date = vulnerability.cve.exploitReleaseDate.isoformat() if hasattr(vulnerability.cve.exploitReleaseDate, 'isoformat') else str(vulnerability.cve.exploitReleaseDate)
            
            if hasattr(vulnerability.cve, 'firstExploitationDate'):
                first_exploitation_date = vulnerability.cve.firstExploitationDate.isoformat() if hasattr(vulnerability.cve.firstExploitationDate, 'isoformat') else str(vulnerability.cve.firstExploitationDate)
            
            # Offending package information
            if hasattr(vulnerability, 'offendingPackage') and vulnerability.offendingPackage:
                offending_pkg = vulnerability.offendingPackage
                offending_package = {
                    'package_name': offending_pkg.packageName if hasattr(offending_pkg, 'packageName') else None,
                    'package_type': offending_pkg.packageType if hasattr(offending_pkg, 'packageType') else None,
                    'package_version': offending_pkg.packageVersion if hasattr(offending_pkg, 'packageVersion') else None,
                    'cpe_uri': offending_pkg.cpeUri if hasattr(offending_pkg, 'cpeUri') else None
                }
            
            # Fixed package information
            if hasattr(vulnerability, 'fixedPackage') and vulnerability.fixedPackage:
                fixed_pkg = vulnerability.fixedPackage
                fixed_package = {
                    'package_name': fixed_pkg.packageName if hasattr(fixed_pkg, 'packageName') else None,
                    'package_type': fixed_pkg.packageType if hasattr(fixed_pkg, 'packageType') else None,
                    'package_version': fixed_pkg.packageVersion if hasattr(fixed_pkg, 'packageVersion') else None,
                    'cpe_uri': fixed_pkg.cpeUri if hasattr(fixed_pkg, 'cpeUri') else None
                }
        
        # Extract mute information
        mute = finding.mute if hasattr(finding, 'mute') else 'UNDEFINED'
        mute_initiator = finding.muteInitiator if hasattr(finding, 'muteInitiator') else None
        mute_update_time = None
        
        if hasattr(finding, 'muteUpdateTime'):
            mute_update_time = finding.muteUpdateTime.isoformat() if hasattr(finding.muteUpdateTime, 'isoformat') else str(finding.muteUpdateTime)
        
        # Extract GCP metadata
        project_display_name = None
        if hasattr(resource, 'gcpMetadata') and resource.gcpMetadata:
            if hasattr(resource.gcpMetadata, 'projectDisplayName'):
                project_display_name = resource.gcpMetadata.projectDisplayName
        
        # Extract Kubernetes information for SOFTWARE_VULNERABILITY
        kubernetes_objects = None
        if finding.category == 'SOFTWARE_VULNERABILITY' and hasattr(finding, 'kubernetes') and finding.kubernetes:
            k8s = finding.kubernetes
            kubernetes_objects = {
                'pods': [],
                'nodes': [],
                'node_pools': [],
                'roles': [],
                'bindings': [],
                'access_reviews': [],
                'objects': []
            }
            
            # Pods
            if hasattr(k8s, 'pods') and k8s.pods:
                kubernetes_objects['pods'] = [
                    {
                        'name': pod.name if hasattr(pod, 'name') else None,
                        'namespace': pod.ns if hasattr(pod, 'ns') else None,
                        'labels': dict(pod.labels) if hasattr(pod, 'labels') else {},
                        'containers': [
                            {
                                'name': container.name if hasattr(container, 'name') else None,
                                'image': container.image if hasattr(container, 'image') else None,
                                'image_id': container.imageId if hasattr(container, 'imageId') else None
                            }
                            for container in pod.containers
                        ] if hasattr(pod, 'containers') else []
                    }
                    for pod in k8s.pods
                ]
            
            # Nodes
            if hasattr(k8s, 'nodes') and k8s.nodes:
                kubernetes_objects['nodes'] = [
                    {
                        'name': node.name if hasattr(node, 'name') else None,
                        'labels': dict(node.labels) if hasattr(node, 'labels') else {}
                    }
                    for node in k8s.nodes
                ]
            
            # Node Pools
            if hasattr(k8s, 'nodePools') and k8s.nodePools:
                kubernetes_objects['node_pools'] = [
                    {
                        'name': pool.name if hasattr(pool, 'name') else None
                    }
                    for pool in k8s.nodePools
                ]
            
            # Roles
            if hasattr(k8s, 'roles') and k8s.roles:
                kubernetes_objects['roles'] = [
                    {
                        'name': role.name if hasattr(role, 'name') else None,
                        'namespace': role.ns if hasattr(role, 'ns') else None,
                        'kind': role.kind if hasattr(role, 'kind') else None
                    }
                    for role in k8s.roles
                ]
            
            # Bindings
            if hasattr(k8s, 'bindings') and k8s.bindings:
                kubernetes_objects['bindings'] = [
                    {
                        'name': binding.name if hasattr(binding, 'name') else None,
                        'namespace': binding.ns if hasattr(binding, 'ns') else None,
                        'role': binding.role.name if hasattr(binding, 'role') and hasattr(binding.role, 'name') else None,
                        'subjects': [
                            {
                                'name': subj.name if hasattr(subj, 'name') else None,
                                'kind': subj.kind if hasattr(subj, 'kind') else None,
                                'namespace': subj.ns if hasattr(subj, 'ns') else None
                            }
                            for subj in binding.subjects
                        ] if hasattr(binding, 'subjects') else []
                    }
                    for binding in k8s.bindings
                ]
            
            # Access Reviews
            if hasattr(k8s, 'accessReviews') and k8s.accessReviews:
                kubernetes_objects['access_reviews'] = [
                    {
                        'group': review.group if hasattr(review, 'group') else None,
                        'ns': review.ns if hasattr(review, 'ns') else None,
                        'name': review.name if hasattr(review, 'name') else None,
                        'resource': review.resource if hasattr(review, 'resource') else None,
                        'subresource': review.subresource if hasattr(review, 'subresource') else None,
                        'verb': review.verb if hasattr(review, 'verb') else None,
                        'version': review.version if hasattr(review, 'version') else None
                    }
                    for review in k8s.accessReviews
                ]
            
            # Objects (generic Kubernetes objects)
            if hasattr(k8s, 'objects') and k8s.objects:
                kubernetes_objects['objects'] = [
                    {
                        'group': obj.group if hasattr(obj, 'group') else None,
                        'kind': obj.kind if hasattr(obj, 'kind') else None,
                        'ns': obj.ns if hasattr(obj, 'ns') else None,
                        'name': obj.name if hasattr(obj, 'name') else None,
                        'containers': [
                            {
                                'name': container.name if hasattr(container, 'name') else None,
                                'image': container.image if hasattr(container, 'image') else None,
                                'image_id': container.imageId if hasattr(container, 'imageId') else None
                            }
                            for container in obj.containers
                        ] if hasattr(obj, 'containers') else []
                    }
                    for obj in k8s.objects
                ]
        
        return {
            # Finding core fields
            'finding_id': finding.name.split('/')[-1],  # Extract ID from full name
            'finding_name': finding.name,
            'finding_parent': finding.parent if hasattr(finding, 'parent') else None,
            'category': finding.category,
            'state': finding.state if hasattr(finding, 'state') else 'UNKNOWN',
            'severity': finding.severity if hasattr(finding, 'severity') else 'UNKNOWN',
            'finding_class': finding.findingClass if hasattr(finding, 'findingClass') else None,
            'description': finding.description if hasattr(finding, 'description') else None,
            
            # Resource fields
            'resource_name': resource.name,
            'resource_display_name': resource.displayName if hasattr(resource, 'displayName') else None,
            'resource_type': resource.type if hasattr(resource, 'type') else None,
            'resource_service': resource.service if hasattr(resource, 'service') else None,
            'resource_location': resource.location if hasattr(resource, 'location') else None,
            'project_id': project_id,
            'project_display_name': project_display_name,
            
            # Mute information
            'mute': mute,
            'mute_initiator': mute_initiator,
            'mute_update_time': mute_update_time,
            
            # Launch state
            'launch_state': finding.launchState if hasattr(finding, 'launchState') else None,
            
            # Vulnerability details
            'cve_id': cve_id,
            'cve_references': cve_references,
            'cvssv3': cvssv3_data,
            'zero_day': zero_day,
            'impact': impact,
            'exploitation_activity': exploitation_activity,
            'exploit_release_date': exploit_release_date,
            'first_exploitation_date': first_exploitation_date,
            
            # Package information
            'offending_package': offending_package,
            'fixed_package': fixed_package,
            
            # Kubernetes information (for SOFTWARE_VULNERABILITY)
            'kubernetes': kubernetes_objects,
            
            # Timestamps
            'create_time': finding.createTime.isoformat() if hasattr(finding, 'createTime') else None,
            'event_time': finding.eventTime.isoformat() if hasattr(finding, 'eventTime') else None,
            
            # Source properties (additional metadata)
            'source_properties': dict(finding.sourceProperties) if hasattr(finding, 'sourceProperties') else {},
            
            # These will be enriched later
            'appcode': None,
            'lob': None
        }
