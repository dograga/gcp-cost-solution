"""Client for fetching vulnerability findings from GCP Security Command Center"""

import logging
import asyncio
from typing import Dict, Any, AsyncIterator
from google.cloud.securitycenter_v2 import SecurityCenterClient
from google.cloud.securitycenter_v2.types import ListFindingsRequest
from google.protobuf.json_format import MessageToDict
import config

logger = logging.getLogger(__name__)


class SCCClient:
    """Client for interacting with GCP Security Command Center API v2"""
    
    def __init__(self):
        self.client = SecurityCenterClient()
        self.org_name = f"organizations/{config.GCP_ORGANIZATION_ID}"
        logger.info(f"Initialized SCC v2 client for organization: {self.org_name}")
    
    def _convert_source_properties(self, source_properties):
        """
        Convert source_properties protobuf map to JSON-serializable dict.
        
        Args:
            source_properties: Protobuf map of source properties
            
        Returns:
            JSON-serializable dictionary
        """
        if not source_properties:
            return {}
        
        try:
            # Convert protobuf objects to dict
            result = {}
            for key, value in source_properties.items():
                try:
                    # Handle repeated/list fields
                    if hasattr(value, '__iter__') and not isinstance(value, (str, bytes)):
                        # It's a list-like object
                        result[key] = [str(item) for item in value]
                    # Handle protobuf messages
                    elif hasattr(value, '_pb'):
                        from google.protobuf.json_format import MessageToDict
                        result[key] = MessageToDict(value._pb)
                    # Handle primitive types
                    else:
                        result[key] = str(value)
                except Exception as e:
                    # Fallback: convert to string
                    logger.debug(f"Converting source_property {key} to string: {e}")
                    try:
                        result[key] = str(value)
                    except:
                        result[key] = None
            return result
        except Exception as e:
            logger.warning(f"Failed to convert source_properties: {e}")
            return {}
    
    def _convert_enum(self, enum_value):
        """
        Convert protobuf enum to string name.
        
        Args:
            enum_value: Protobuf enum value
            
        Returns:
            String name of enum or None
        """
        if enum_value is None:
            return None
        
        try:
            # Try to get the enum name
            if hasattr(enum_value, 'name'):
                return enum_value.name
            
            # For numeric enums, convert to string
            return str(enum_value)
        except Exception as e:
            logger.warning(f"Failed to convert enum {enum_value}: {e}")
            return str(enum_value) if enum_value is not None else None
    
    def _convert_timestamp(self, timestamp):
        """
        Convert protobuf timestamp to ISO format string.
        
        Args:
            timestamp: Protobuf timestamp object
            
        Returns:
            ISO format string or None
        """
        if not timestamp:
            return None
        
        try:
            # For protobuf Timestamp, check if it has seconds/nanos
            if hasattr(timestamp, 'seconds') or hasattr(timestamp, 'nanos'):
                # Convert to datetime then to ISO string
                from datetime import datetime, timezone
                if hasattr(timestamp, 'seconds'):
                    dt = datetime.fromtimestamp(timestamp.seconds, tz=timezone.utc)
                    if hasattr(timestamp, 'nanos'):
                        # Add microseconds from nanos
                        dt = dt.replace(microsecond=timestamp.nanos // 1000)
                    return dt.isoformat()
            
            # Try isoformat() method
            if hasattr(timestamp, 'isoformat'):
                return timestamp.isoformat()
            
            # Try ToJsonString() for protobuf timestamps
            if hasattr(timestamp, 'ToJsonString'):
                return timestamp.ToJsonString()
            
            # Try string conversion
            timestamp_str = str(timestamp)
            if timestamp_str and timestamp_str != '' and timestamp_str != 'seconds: 0\n':
                return timestamp_str
            
            return None
        except Exception as e:
            logger.warning(f"Failed to convert timestamp {timestamp}: {e}")
            return str(timestamp) if timestamp else None
    
    async def fetch_vulnerability_findings(self) -> AsyncIterator[Dict[str, Any]]:
        """
        Fetch vulnerability findings from SCC v2 asynchronously.
        Yields findings one at a time for memory efficiency.
        
        Yields:
            Dictionary containing finding data
        """
        # API v2 parent format: organizations/{org}/sources/{source}
        # Use "-" for source to search across all sources
        parent = f"{self.org_name}/sources/-"
        
        # Build request
        request_params = {
            "parent": parent,
            "page_size": config.SCC_PAGE_SIZE
        }
        
        # Add filter if provided and not empty
        if config.SCC_FINDING_FILTER and config.SCC_FINDING_FILTER.strip():
            request_params["filter"] = config.SCC_FINDING_FILTER
            logger.info(f"Using filter: {config.SCC_FINDING_FILTER}")
        else:
            logger.info("No filter applied - fetching all findings")
        
        request = ListFindingsRequest(**request_params)
        
        logger.info(f"Fetching findings from parent: {parent}")
        logger.info(f"Page size: {config.SCC_PAGE_SIZE}")
        
        try:
            # Run the synchronous API call in executor to avoid blocking
            loop = asyncio.get_event_loop()
            findings_iterator = await loop.run_in_executor(
                None, 
                self.client.list_findings, 
                request
            )
            
            count = 0
            # Convert synchronous iterator to async iterator
            for finding_result in findings_iterator:
                finding = finding_result.finding
                resource = finding_result.resource
                
                # Log first finding for debugging
                if count == 0:
                    import json
                    logger.info("="*80)
                    logger.info("RAW FINDING ATTRIBUTES")
                    logger.info("="*80)
                    
                    # Check CVSS v3 specifically
                    if hasattr(finding, 'vulnerability') and finding.vulnerability:
                        vuln = finding.vulnerability
                        if hasattr(vuln, 'cve') and vuln.cve:
                            cve = vuln.cve
                            if hasattr(cve, 'cvssv3'):
                                cvssv3 = cve.cvssv3
                                logger.info(f"CVSSV3 exists: True")
                                logger.info(f"CVSSV3 has base_score: {hasattr(cvssv3, 'base_score')}")
                                if hasattr(cvssv3, 'base_score'):
                                    logger.info(f"CVSSV3 base_score value: {cvssv3.base_score}")
                                    logger.info(f"CVSSV3 base_score type: {type(cvssv3.base_score)}")
                                    logger.info(f"CVSSV3 base_score bool: {bool(cvssv3.base_score)}")
                    logger.info("="*80)
                
                # Extract relevant data
                finding_data = self._extract_finding_data(finding, resource)
                
                # Log first extracted data for comparison
                if count == 0:
                    logger.info("="*80)
                    logger.info("EXTRACTED DATA (What will be stored in DB)")
                    logger.info("="*80)
                    logger.info(f"create_time: {finding_data.get('create_time')}")
                    logger.info(f"event_time: {finding_data.get('event_time')}")
                    logger.info(f"cvssv3: {finding_data.get('cvssv3')}")
                    logger.info("="*80)
                    logger.info("FULL EXTRACTED DATA:")
                    logger.info(json.dumps(finding_data, indent=2, default=str))
                    logger.info("="*80)
                
                count += 1
                if count % 1000 == 0:
                    logger.info(f"Fetched {count} findings from SCC...")
                
                # Yield control back to event loop periodically
                if count % 100 == 0:
                    await asyncio.sleep(0)
                
                yield finding_data
            
            logger.info(f"Total findings fetched: {count}")
            
        except Exception as e:
            logger.error(f"Error fetching findings from SCC: {e}")
            raise
    
    def _extract_finding_data(self, finding, resource) -> Dict[str, Any]:
        """
        Extract and structure finding data with comprehensive vulnerability details.
        
        Args:
            finding: SCC Finding object
            resource: SCC Resource object
            
        Returns:
            Dictionary with structured finding data
        """
        # Extract project ID from resource name
        # Format: //cloudresourcemanager.googleapis.com/projects/123456
        project_id = None
        if resource.name:
            parts = resource.name.split('/')
            if 'projects' in parts:
                idx = parts.index('projects')
                if idx + 1 < len(parts):
                    project_id = parts[idx + 1]
        
        # Extract vulnerability details
        vulnerability = finding.vulnerability if hasattr(finding, 'vulnerability') else None
        
        # Initialize vulnerability fields
        cve_id = None
        cve_references = []
        cvssv3_data = None
        zero_day = None
        impact = None
        exploitation_activity = None
        exploit_release_date = None
        first_exploitation_date = None
        offending_package = None
        fixed_package = None
        
        if vulnerability:
            # CVE details
            if hasattr(vulnerability, 'cve') and vulnerability.cve:
                cve_id = vulnerability.cve.id if hasattr(vulnerability.cve, 'id') else None
                
                # CVE references
                if hasattr(vulnerability.cve, 'references'):
                    cve_references = [ref.uri if hasattr(ref, 'uri') else str(ref) 
                                     for ref in vulnerability.cve.references]
                
                # CVSS v3 details
                if hasattr(vulnerability.cve, 'cvssv3') and vulnerability.cve.cvssv3:
                    cvssv3 = vulnerability.cve.cvssv3
                    # Check if cvssv3 has actual data (base_score >= 0 is valid, so check for None instead)
                    if hasattr(cvssv3, 'base_score') and cvssv3.base_score is not None:
                        cvssv3_data = {
                            'base_score': float(cvssv3.base_score) if hasattr(cvssv3, 'base_score') else None,
                            'attack_vector': self._convert_enum(cvssv3.attack_vector) if hasattr(cvssv3, 'attack_vector') else None,
                            'attack_complexity': self._convert_enum(cvssv3.attack_complexity) if hasattr(cvssv3, 'attack_complexity') else None,
                            'privileges_required': self._convert_enum(cvssv3.privileges_required) if hasattr(cvssv3, 'privileges_required') else None,
                            'user_interaction': self._convert_enum(cvssv3.user_interaction) if hasattr(cvssv3, 'user_interaction') else None,
                            'scope': self._convert_enum(cvssv3.scope) if hasattr(cvssv3, 'scope') else None,
                            'confidentiality_impact': self._convert_enum(cvssv3.confidentiality_impact) if hasattr(cvssv3, 'confidentiality_impact') else None,
                            'integrity_impact': self._convert_enum(cvssv3.integrity_impact) if hasattr(cvssv3, 'integrity_impact') else None,
                            'availability_impact': self._convert_enum(cvssv3.availability_impact) if hasattr(cvssv3, 'availability_impact') else None
                        }
            
            # Zero day indicator
            if hasattr(vulnerability.cve, 'zero_day'):
                zero_day = vulnerability.cve.zero_day
            
            # Impact description
            if hasattr(vulnerability.cve, 'impact'):
                impact = vulnerability.cve.impact
            
            # Exploitation activity (enum to string)
            if hasattr(vulnerability.cve, 'exploitation_activity'):
                exploitation_activity = self._convert_enum(vulnerability.cve.exploitation_activity)
            
            # Exploit dates
            if hasattr(vulnerability.cve, 'exploit_release_date'):
                exploit_release_date = self._convert_timestamp(vulnerability.cve.exploit_release_date)
            
            if hasattr(vulnerability.cve, 'first_exploitation_date'):
                first_exploitation_date = self._convert_timestamp(vulnerability.cve.first_exploitation_date)
            
            # Offending package information
            if hasattr(vulnerability, 'offending_package') and vulnerability.offending_package:
                offending_pkg = vulnerability.offending_package
                offending_package = {
                    'package_name': offending_pkg.package_name if hasattr(offending_pkg, 'package_name') else None,
                    'package_type': self._convert_enum(offending_pkg.package_type) if hasattr(offending_pkg, 'package_type') else None,
                    'package_version': offending_pkg.package_version if hasattr(offending_pkg, 'package_version') else None,
                    'cpe_uri': offending_pkg.cpe_uri if hasattr(offending_pkg, 'cpe_uri') else None
                }
            
            # Fixed package information
            if hasattr(vulnerability, 'fixed_package') and vulnerability.fixed_package:
                fixed_pkg = vulnerability.fixed_package
                fixed_package = {
                    'package_name': fixed_pkg.package_name if hasattr(fixed_pkg, 'package_name') else None,
                    'package_type': self._convert_enum(fixed_pkg.package_type) if hasattr(fixed_pkg, 'package_type') else None,
                    'package_version': fixed_pkg.package_version if hasattr(fixed_pkg, 'package_version') else None,
                    'cpe_uri': fixed_pkg.cpe_uri if hasattr(fixed_pkg, 'cpe_uri') else None
                }
        
        # Extract mute information (convert enum to string)
        mute = self._convert_enum(finding.mute) if hasattr(finding, 'mute') else 'UNDEFINED'
        mute_initiator = finding.mute_initiator if hasattr(finding, 'mute_initiator') else None
        mute_update_time = self._convert_timestamp(finding.mute_update_time) if hasattr(finding, 'mute_update_time') and finding.mute_update_time else None
        
        # Extract GCP metadata
        project_display_name = None
        if hasattr(resource, 'gcp_metadata') and resource.gcp_metadata:
            if hasattr(resource.gcp_metadata, 'project_display_name'):
                project_display_name = resource.gcp_metadata.project_display_name
        
        # Extract security bulletin information
        security_bulletin = None
        if vulnerability and hasattr(vulnerability, 'security_bulletin') and vulnerability.security_bulletin:
            bulletin = vulnerability.security_bulletin
            security_bulletin = {
                'bulletin_id': bulletin.bulletin_id if hasattr(bulletin, 'bulletin_id') else None,
                'submission_time': self._convert_timestamp(bulletin.submission_time) if hasattr(bulletin, 'submission_time') else None,
                'suggested_upgrade_version': bulletin.suggested_upgrade_version if hasattr(bulletin, 'suggested_upgrade_version') else None
            }
        
        # Extract Kubernetes information (for all categories that have it)
        kubernetes_objects = None
        if hasattr(finding, 'kubernetes') and finding.kubernetes:
            k8s = finding.kubernetes
            kubernetes_objects = {
                'pods': [],
                'nodes': [],
                'node_pools': [],
                'roles': [],
                'bindings': [],
                'access_reviews': [],
                'objects': []
            }
            
            # Pods
            if hasattr(k8s, 'pods') and k8s.pods:
                kubernetes_objects['pods'] = [
                    {
                        'name': pod.name if hasattr(pod, 'name') else None,
                        'namespace': pod.ns if hasattr(pod, 'ns') else None,
                        'labels': dict(pod.labels) if hasattr(pod, 'labels') else {},
                        'containers': [
                            {
                                'name': container.name if hasattr(container, 'name') else None,
                                'image': container.image if hasattr(container, 'image') else None,
                                'image_id': container.imageId if hasattr(container, 'imageId') else None
                            }
                            for container in pod.containers
                        ] if hasattr(pod, 'containers') else []
                    }
                    for pod in k8s.pods
                ]
            
            # Nodes
            if hasattr(k8s, 'nodes') and k8s.nodes:
                kubernetes_objects['nodes'] = [
                    {
                        'name': node.name if hasattr(node, 'name') else None,
                        'labels': dict(node.labels) if hasattr(node, 'labels') else {}
                    }
                    for node in k8s.nodes
                ]
            
            # Node Pools
            if hasattr(k8s, 'nodePools') and k8s.nodePools:
                kubernetes_objects['node_pools'] = [
                    {
                        'name': pool.name if hasattr(pool, 'name') else None
                    }
                    for pool in k8s.nodePools
                ]
            
            # Roles
            if hasattr(k8s, 'roles') and k8s.roles:
                kubernetes_objects['roles'] = [
                    {
                        'name': role.name if hasattr(role, 'name') else None,
                        'namespace': role.ns if hasattr(role, 'ns') else None,
                        'kind': role.kind if hasattr(role, 'kind') else None
                    }
                    for role in k8s.roles
                ]
            
            # Bindings
            if hasattr(k8s, 'bindings') and k8s.bindings:
                kubernetes_objects['bindings'] = [
                    {
                        'name': binding.name if hasattr(binding, 'name') else None,
                        'namespace': binding.ns if hasattr(binding, 'ns') else None,
                        'role': binding.role.name if hasattr(binding, 'role') and hasattr(binding.role, 'name') else None,
                        'subjects': [
                            {
                                'name': subj.name if hasattr(subj, 'name') else None,
                                'kind': subj.kind if hasattr(subj, 'kind') else None,
                                'namespace': subj.ns if hasattr(subj, 'ns') else None
                            }
                            for subj in binding.subjects
                        ] if hasattr(binding, 'subjects') else []
                    }
                    for binding in k8s.bindings
                ]
            
            # Access Reviews
            if hasattr(k8s, 'accessReviews') and k8s.accessReviews:
                kubernetes_objects['access_reviews'] = [
                    {
                        'group': review.group if hasattr(review, 'group') else None,
                        'ns': review.ns if hasattr(review, 'ns') else None,
                        'name': review.name if hasattr(review, 'name') else None,
                        'resource': review.resource if hasattr(review, 'resource') else None,
                        'subresource': review.subresource if hasattr(review, 'subresource') else None,
                        'verb': review.verb if hasattr(review, 'verb') else None,
                        'version': review.version if hasattr(review, 'version') else None
                    }
                    for review in k8s.accessReviews
                ]
            
            # Objects (generic Kubernetes objects)
            if hasattr(k8s, 'objects') and k8s.objects:
                kubernetes_objects['objects'] = [
                    {
                        'group': obj.group if hasattr(obj, 'group') else None,
                        'kind': obj.kind if hasattr(obj, 'kind') else None,
                        'ns': obj.ns if hasattr(obj, 'ns') else None,
                        'name': obj.name if hasattr(obj, 'name') else None,
                        'containers': [
                            {
                                'name': container.name if hasattr(container, 'name') else None,
                                'image': container.image if hasattr(container, 'image') else None,
                                'image_id': container.imageId if hasattr(container, 'imageId') else None
                            }
                            for container in obj.containers
                        ] if hasattr(obj, 'containers') else []
                    }
                    for obj in k8s.objects
                ]
        
        return {
            # Finding core fields
            'finding_id': finding.name.split('/')[-1],  # Extract ID from full name
            'finding_name': finding.name,
            'canonical_name': finding.canonical_name if hasattr(finding, 'canonical_name') else None,
            'finding_parent': finding.parent if hasattr(finding, 'parent') else None,
            'parent_display_name': finding.parent_display_name if hasattr(finding, 'parent_display_name') else None,
            'category': finding.category,
            'state': self._convert_enum(finding.state) if hasattr(finding, 'state') else 'UNKNOWN',
            'severity': self._convert_enum(finding.severity) if hasattr(finding, 'severity') else 'UNKNOWN',
            'finding_class': self._convert_enum(finding.finding_class) if hasattr(finding, 'finding_class') else None,
            'description': finding.description if hasattr(finding, 'description') else None,
            'next_steps': finding.next_steps if hasattr(finding, 'next_steps') else None,
            'external_uri': finding.external_uri if hasattr(finding, 'external_uri') else None,
            
            # Resource fields
            'resource_name': resource.name,
            'resource_display_name': resource.display_name if hasattr(resource, 'display_name') else None,
            'resource_type': resource.type if hasattr(resource, 'type') else None,
            'resource_service': resource.service if hasattr(resource, 'service') else None,
            'resource_location': resource.location if hasattr(resource, 'location') else None,
            'project_id': project_id,
            'project_display_name': project_display_name,
            
            # Mute information
            'mute': mute,
            'mute_initiator': mute_initiator,
            'mute_update_time': mute_update_time,
            
            # Launch state (enum to string)
            'launch_state': self._convert_enum(finding.launch_state) if hasattr(finding, 'launch_state') else None,
            
            # Vulnerability details
            'cve_id': cve_id,
            'cve_references': cve_references,
            'cvssv3': cvssv3_data,
            'zero_day': zero_day,
            'impact': impact,
            'exploitation_activity': exploitation_activity,
            'exploit_release_date': exploit_release_date,
            'first_exploitation_date': first_exploitation_date,
            
            # Package information
            'offending_package': offending_package,
            'fixed_package': fixed_package,
            'security_bulletin': security_bulletin,
            
            # Kubernetes information (for SOFTWARE_VULNERABILITY)
            'kubernetes': kubernetes_objects,
            
            # Timestamps
            'create_time': self._convert_timestamp(finding.create_time) if hasattr(finding, 'create_time') and finding.create_time else None,
            'event_time': self._convert_timestamp(finding.event_time) if hasattr(finding, 'event_time') and finding.event_time else None,
            
            # Source properties (additional metadata) - convert to JSON-serializable dict
            'source_properties': self._convert_source_properties(finding.source_properties) if hasattr(finding, 'source_properties') else {},
            
            # These will be enriched later
            'appcode': None,
            'lob': None
        }
