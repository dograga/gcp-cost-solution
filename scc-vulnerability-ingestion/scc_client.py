"""Client for fetching vulnerability findings from GCP Security Command Center"""

import logging
import asyncio
from typing import Dict, Any, AsyncIterator
from google.cloud.securitycenter_v2 import SecurityCenterClient
from google.cloud.securitycenter_v2.types import ListFindingsRequest
import config

logger = logging.getLogger(__name__)


class SCCClient:
    """Client for interacting with GCP Security Command Center API v2"""
    
    def __init__(self):
        self.client = SecurityCenterClient()
        self.org_name = f"organizations/{config.GCP_ORGANIZATION_ID}"
        logger.info(f"Initialized SCC v2 client for organization: {self.org_name}")
    
    def _convert_timestamp(self, timestamp):
        """
        Convert protobuf timestamp to ISO format string.
        
        Args:
            timestamp: Protobuf timestamp object
            
        Returns:
            ISO format string or None
        """
        if not timestamp:
            return None
        
        try:
            # Try isoformat() method first
            if hasattr(timestamp, 'isoformat'):
                return timestamp.isoformat()
            
            # Try ToJsonString() for protobuf timestamps
            if hasattr(timestamp, 'ToJsonString'):
                return timestamp.ToJsonString()
            
            # Try string conversion
            timestamp_str = str(timestamp)
            if timestamp_str and timestamp_str != '':
                return timestamp_str
            
            return None
        except Exception as e:
            logger.warning(f"Failed to convert timestamp: {e}")
            return str(timestamp) if timestamp else None
    
    async def fetch_vulnerability_findings(self) -> AsyncIterator[Dict[str, Any]]:
        """
        Fetch vulnerability findings from SCC v2 asynchronously.
        Yields findings one at a time for memory efficiency.
        
        Yields:
            Dictionary containing finding data
        """
        # API v2 parent format: organizations/{org}/sources/{source}
        # Use "-" for source to search across all sources
        parent = f"{self.org_name}/sources/-"
        
        # Build request
        request_params = {
            "parent": parent,
            "page_size": config.SCC_PAGE_SIZE
        }
        
        # Add filter if provided and not empty
        if config.SCC_FINDING_FILTER and config.SCC_FINDING_FILTER.strip():
            request_params["filter"] = config.SCC_FINDING_FILTER
            logger.info(f"Using filter: {config.SCC_FINDING_FILTER}")
        else:
            logger.info("No filter applied - fetching all findings")
        
        request = ListFindingsRequest(**request_params)
        
        logger.info(f"Fetching findings from parent: {parent}")
        logger.info(f"Page size: {config.SCC_PAGE_SIZE}")
        
        try:
            # Run the synchronous API call in executor to avoid blocking
            loop = asyncio.get_event_loop()
            findings_iterator = await loop.run_in_executor(
                None, 
                self.client.list_findings, 
                request
            )
            
            count = 0
            # Convert synchronous iterator to async iterator
            for finding_result in findings_iterator:
                finding = finding_result.finding
                resource = finding_result.resource
                
                # Log first finding for debugging
                if count == 0:
                    logger.info("="*80)
                    logger.info("RAW FINDING (First Finding for Debugging)")
                    logger.info("="*80)
                    logger.info(f"Finding Object: {finding}")
                    logger.info(f"Resource Object: {resource}")
                    logger.info("="*80)
                
                # Extract relevant data
                finding_data = self._extract_finding_data(finding, resource)
                
                # Log first extracted data for comparison
                if count == 0:
                    import json
                    logger.info("="*80)
                    logger.info("EXTRACTED DATA (What will be stored in DB)")
                    logger.info("="*80)
                    logger.info(json.dumps(finding_data, indent=2, default=str))
                    logger.info("="*80)
                
                count += 1
                if count % 1000 == 0:
                    logger.info(f"Fetched {count} findings from SCC...")
                
                # Yield control back to event loop periodically
                if count % 100 == 0:
                    await asyncio.sleep(0)
                
                yield finding_data
            
            logger.info(f"Total findings fetched: {count}")
            
        except Exception as e:
            logger.error(f"Error fetching findings from SCC: {e}")
            raise
    
    def _extract_finding_data(self, finding, resource) -> Dict[str, Any]:
        """
        Extract and structure finding data with comprehensive vulnerability details.
        
        Args:
            finding: SCC Finding object
            resource: SCC Resource object
            
        Returns:
            Dictionary with structured finding data
        """
        # Extract project ID from resource name
        # Format: //cloudresourcemanager.googleapis.com/projects/123456
        project_id = None
        if resource.name:
            parts = resource.name.split('/')
            if 'projects' in parts:
                idx = parts.index('projects')
                if idx + 1 < len(parts):
                    project_id = parts[idx + 1]
        
        # Extract vulnerability details
        vulnerability = finding.vulnerability if hasattr(finding, 'vulnerability') else None
        
        # Initialize vulnerability fields
        cve_id = None
        cve_references = []
        cvssv3_data = None
        zero_day = None
        impact = None
        exploitation_activity = None
        exploit_release_date = None
        first_exploitation_date = None
        offending_package = None
        fixed_package = None
        
        if vulnerability:
            # CVE details
            if hasattr(vulnerability, 'cve') and vulnerability.cve:
                cve_id = vulnerability.cve.id if hasattr(vulnerability.cve, 'id') else None
                
                # CVE references
                if hasattr(vulnerability.cve, 'references'):
                    cve_references = [ref.uri if hasattr(ref, 'uri') else str(ref) 
                                     for ref in vulnerability.cve.references]
                
                # CVSS v3 details
                if hasattr(vulnerability.cve, 'cvssv3') and vulnerability.cve.cvssv3:
                    cvssv3 = vulnerability.cve.cvssv3
                    # Check if cvssv3 has actual data (not just empty object)
                    if hasattr(cvssv3, 'baseScore') and cvssv3.baseScore:
                        cvssv3_data = {
                            'base_score': float(cvssv3.baseScore) if hasattr(cvssv3, 'baseScore') else None,
                            'attack_vector': str(cvssv3.attackVector) if hasattr(cvssv3, 'attackVector') else None,
                            'attack_complexity': str(cvssv3.attackComplexity) if hasattr(cvssv3, 'attackComplexity') else None,
                            'privileges_required': str(cvssv3.privilegesRequired) if hasattr(cvssv3, 'privilegesRequired') else None,
                            'user_interaction': str(cvssv3.userInteraction) if hasattr(cvssv3, 'userInteraction') else None,
                            'scope': str(cvssv3.scope) if hasattr(cvssv3, 'scope') else None,
                            'confidentiality_impact': str(cvssv3.confidentialityImpact) if hasattr(cvssv3, 'confidentialityImpact') else None,
                            'integrity_impact': str(cvssv3.integrityImpact) if hasattr(cvssv3, 'integrityImpact') else None,
                            'availability_impact': str(cvssv3.availabilityImpact) if hasattr(cvssv3, 'availabilityImpact') else None
                        }
            
            # Zero day indicator
            if hasattr(vulnerability.cve, 'zeroDay'):
                zero_day = vulnerability.cve.zeroDay
            
            # Impact description
            if hasattr(vulnerability.cve, 'impact'):
                impact = vulnerability.cve.impact
            
            # Exploitation activity (enum to string)
            if hasattr(vulnerability.cve, 'exploitationActivity'):
                exploitation_activity = str(vulnerability.cve.exploitationActivity)
            
            # Exploit dates
            if hasattr(vulnerability.cve, 'exploitReleaseDate'):
                exploit_release_date = self._convert_timestamp(vulnerability.cve.exploitReleaseDate)
            
            if hasattr(vulnerability.cve, 'firstExploitationDate'):
                first_exploitation_date = self._convert_timestamp(vulnerability.cve.firstExploitationDate)
            
            # Offending package information
            if hasattr(vulnerability, 'offendingPackage') and vulnerability.offendingPackage:
                offending_pkg = vulnerability.offendingPackage
                offending_package = {
                    'package_name': offending_pkg.packageName if hasattr(offending_pkg, 'packageName') else None,
                    'package_type': str(offending_pkg.packageType) if hasattr(offending_pkg, 'packageType') else None,
                    'package_version': offending_pkg.packageVersion if hasattr(offending_pkg, 'packageVersion') else None,
                    'cpe_uri': offending_pkg.cpeUri if hasattr(offending_pkg, 'cpeUri') else None
                }
            
            # Fixed package information
            if hasattr(vulnerability, 'fixedPackage') and vulnerability.fixedPackage:
                fixed_pkg = vulnerability.fixedPackage
                fixed_package = {
                    'package_name': fixed_pkg.packageName if hasattr(fixed_pkg, 'packageName') else None,
                    'package_type': str(fixed_pkg.packageType) if hasattr(fixed_pkg, 'packageType') else None,
                    'package_version': fixed_pkg.packageVersion if hasattr(fixed_pkg, 'packageVersion') else None,
                    'cpe_uri': fixed_pkg.cpeUri if hasattr(fixed_pkg, 'cpeUri') else None
                }
        
        # Extract mute information (convert enum to string)
        mute = str(finding.mute) if hasattr(finding, 'mute') else 'UNDEFINED'
        mute_initiator = finding.muteInitiator if hasattr(finding, 'muteInitiator') else None
        mute_update_time = self._convert_timestamp(finding.muteUpdateTime) if hasattr(finding, 'muteUpdateTime') and finding.muteUpdateTime else None
        
        # Extract GCP metadata
        project_display_name = None
        if hasattr(resource, 'gcpMetadata') and resource.gcpMetadata:
            if hasattr(resource.gcpMetadata, 'projectDisplayName'):
                project_display_name = resource.gcpMetadata.projectDisplayName
        
        # Extract security bulletin information
        security_bulletin = None
        if vulnerability and hasattr(vulnerability, 'securityBulletin') and vulnerability.securityBulletin:
            bulletin = vulnerability.securityBulletin
            security_bulletin = {
                'bulletin_id': bulletin.bulletinId if hasattr(bulletin, 'bulletinId') else None,
                'submission_time': self._convert_timestamp(bulletin.submissionTime) if hasattr(bulletin, 'submissionTime') else None,
                'suggested_upgrade_version': bulletin.suggestedUpgradeVersion if hasattr(bulletin, 'suggestedUpgradeVersion') else None
            }
        
        # Extract Kubernetes information (for all categories that have it)
        kubernetes_objects = None
        if hasattr(finding, 'kubernetes') and finding.kubernetes:
            k8s = finding.kubernetes
            kubernetes_objects = {
                'pods': [],
                'nodes': [],
                'node_pools': [],
                'roles': [],
                'bindings': [],
                'access_reviews': [],
                'objects': []
            }
            
            # Pods
            if hasattr(k8s, 'pods') and k8s.pods:
                kubernetes_objects['pods'] = [
                    {
                        'name': pod.name if hasattr(pod, 'name') else None,
                        'namespace': pod.ns if hasattr(pod, 'ns') else None,
                        'labels': dict(pod.labels) if hasattr(pod, 'labels') else {},
                        'containers': [
                            {
                                'name': container.name if hasattr(container, 'name') else None,
                                'image': container.image if hasattr(container, 'image') else None,
                                'image_id': container.imageId if hasattr(container, 'imageId') else None
                            }
                            for container in pod.containers
                        ] if hasattr(pod, 'containers') else []
                    }
                    for pod in k8s.pods
                ]
            
            # Nodes
            if hasattr(k8s, 'nodes') and k8s.nodes:
                kubernetes_objects['nodes'] = [
                    {
                        'name': node.name if hasattr(node, 'name') else None,
                        'labels': dict(node.labels) if hasattr(node, 'labels') else {}
                    }
                    for node in k8s.nodes
                ]
            
            # Node Pools
            if hasattr(k8s, 'nodePools') and k8s.nodePools:
                kubernetes_objects['node_pools'] = [
                    {
                        'name': pool.name if hasattr(pool, 'name') else None
                    }
                    for pool in k8s.nodePools
                ]
            
            # Roles
            if hasattr(k8s, 'roles') and k8s.roles:
                kubernetes_objects['roles'] = [
                    {
                        'name': role.name if hasattr(role, 'name') else None,
                        'namespace': role.ns if hasattr(role, 'ns') else None,
                        'kind': role.kind if hasattr(role, 'kind') else None
                    }
                    for role in k8s.roles
                ]
            
            # Bindings
            if hasattr(k8s, 'bindings') and k8s.bindings:
                kubernetes_objects['bindings'] = [
                    {
                        'name': binding.name if hasattr(binding, 'name') else None,
                        'namespace': binding.ns if hasattr(binding, 'ns') else None,
                        'role': binding.role.name if hasattr(binding, 'role') and hasattr(binding.role, 'name') else None,
                        'subjects': [
                            {
                                'name': subj.name if hasattr(subj, 'name') else None,
                                'kind': subj.kind if hasattr(subj, 'kind') else None,
                                'namespace': subj.ns if hasattr(subj, 'ns') else None
                            }
                            for subj in binding.subjects
                        ] if hasattr(binding, 'subjects') else []
                    }
                    for binding in k8s.bindings
                ]
            
            # Access Reviews
            if hasattr(k8s, 'accessReviews') and k8s.accessReviews:
                kubernetes_objects['access_reviews'] = [
                    {
                        'group': review.group if hasattr(review, 'group') else None,
                        'ns': review.ns if hasattr(review, 'ns') else None,
                        'name': review.name if hasattr(review, 'name') else None,
                        'resource': review.resource if hasattr(review, 'resource') else None,
                        'subresource': review.subresource if hasattr(review, 'subresource') else None,
                        'verb': review.verb if hasattr(review, 'verb') else None,
                        'version': review.version if hasattr(review, 'version') else None
                    }
                    for review in k8s.accessReviews
                ]
            
            # Objects (generic Kubernetes objects)
            if hasattr(k8s, 'objects') and k8s.objects:
                kubernetes_objects['objects'] = [
                    {
                        'group': obj.group if hasattr(obj, 'group') else None,
                        'kind': obj.kind if hasattr(obj, 'kind') else None,
                        'ns': obj.ns if hasattr(obj, 'ns') else None,
                        'name': obj.name if hasattr(obj, 'name') else None,
                        'containers': [
                            {
                                'name': container.name if hasattr(container, 'name') else None,
                                'image': container.image if hasattr(container, 'image') else None,
                                'image_id': container.imageId if hasattr(container, 'imageId') else None
                            }
                            for container in obj.containers
                        ] if hasattr(obj, 'containers') else []
                    }
                    for obj in k8s.objects
                ]
        
        return {
            # Finding core fields
            'finding_id': finding.name.split('/')[-1],  # Extract ID from full name
            'finding_name': finding.name,
            'canonical_name': finding.canonicalName if hasattr(finding, 'canonicalName') else None,
            'finding_parent': finding.parent if hasattr(finding, 'parent') else None,
            'parent_display_name': finding.parentDisplayName if hasattr(finding, 'parentDisplayName') else None,
            'category': finding.category,
            'state': str(finding.state) if hasattr(finding, 'state') else 'UNKNOWN',
            'severity': str(finding.severity) if hasattr(finding, 'severity') else 'UNKNOWN',
            'finding_class': str(finding.findingClass) if hasattr(finding, 'findingClass') else None,
            'description': finding.description if hasattr(finding, 'description') else None,
            'next_steps': finding.nextSteps if hasattr(finding, 'nextSteps') else None,
            'external_uri': finding.externalUri if hasattr(finding, 'externalUri') else None,
            
            # Resource fields
            'resource_name': resource.name,
            'resource_display_name': resource.displayName if hasattr(resource, 'displayName') else None,
            'resource_type': resource.type if hasattr(resource, 'type') else None,
            'resource_service': resource.service if hasattr(resource, 'service') else None,
            'resource_location': resource.location if hasattr(resource, 'location') else None,
            'project_id': project_id,
            'project_display_name': project_display_name,
            
            # Mute information
            'mute': mute,
            'mute_initiator': mute_initiator,
            'mute_update_time': mute_update_time,
            
            # Launch state (enum to string)
            'launch_state': str(finding.launchState) if hasattr(finding, 'launchState') else None,
            
            # Vulnerability details
            'cve_id': cve_id,
            'cve_references': cve_references,
            'cvssv3': cvssv3_data,
            'zero_day': zero_day,
            'impact': impact,
            'exploitation_activity': exploitation_activity,
            'exploit_release_date': exploit_release_date,
            'first_exploitation_date': first_exploitation_date,
            
            # Package information
            'offending_package': offending_package,
            'fixed_package': fixed_package,
            'security_bulletin': security_bulletin,
            
            # Kubernetes information (for SOFTWARE_VULNERABILITY)
            'kubernetes': kubernetes_objects,
            
            # Timestamps
            'create_time': self._convert_timestamp(finding.createTime) if hasattr(finding, 'createTime') and finding.createTime else None,
            'event_time': self._convert_timestamp(finding.eventTime) if hasattr(finding, 'eventTime') and finding.eventTime else None,
            
            # Source properties (additional metadata)
            'source_properties': dict(finding.sourceProperties) if hasattr(finding, 'sourceProperties') else {},
            
            # These will be enriched later
            'appcode': None,
            'lob': None
        }
