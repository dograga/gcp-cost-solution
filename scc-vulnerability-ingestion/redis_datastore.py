"""Redis datastore implementation"""

from typing import List, Dict, Any, Optional
import logging
import json
import redis.asyncio as redis
import config

logger = logging.getLogger(__name__)


class RedisDatastore:
    """Redis implementation with pipeline operations for atomicity"""
    
    def __init__(self):
        self.redis_client = None
        self.key_prefix = config.REDIS_KEY_PREFIX
        self.key_ttl = config.REDIS_KEY_TTL
        self.mapping_key = f"{self.key_prefix}project_mapping"
        logger.info(f"Initialized Redis datastore: {config.REDIS_HOST}:{config.REDIS_PORT}")
    
    async def _get_client(self):
        """Get or create Redis client"""
        if self.redis_client is None:
            self.redis_client = await redis.Redis(
                host=config.REDIS_HOST,
                port=config.REDIS_PORT,
                password=config.REDIS_PASSWORD if config.REDIS_PASSWORD else None,
                db=config.REDIS_DB,
                decode_responses=False  # We'll handle JSON encoding
            )
        return self.redis_client
    
    async def upsert_vulnerabilities(self, vulnerabilities: List[Dict[str, Any]]) -> int:
        """
        Insert vulnerabilities using Redis pipeline for atomicity.
        Using finding_id as key automatically handles upsert.
        Redis pipeline executes all commands atomically.
        """
        if not vulnerabilities:
            return 0
        
        client = await self._get_client()
        total_upserted = 0
        
        # Process in batches to avoid memory issues
        batch_size = 1000
        
        for i in range(0, len(vulnerabilities), batch_size):
            batch_vulnerabilities = vulnerabilities[i:i + batch_size]
            
            # Use pipeline for atomic batch operations
            async with client.pipeline(transaction=True) as pipe:
                for vuln in batch_vulnerabilities:
                    finding_id = vuln.get('finding_id')
                    if not finding_id:
                        logger.warning(f"Skipping vulnerability without finding_id: {vuln}")
                        continue
                    
                    # Use finding_id as key - this automatically upserts
                    key = f"{self.key_prefix}{finding_id}"
                    value = json.dumps(vuln)
                    
                    # SET with EX for TTL
                    pipe.set(key, value, ex=self.key_ttl)
                    total_upserted += 1
                
                # Execute pipeline atomically
                try:
                    await pipe.execute()
                    logger.info(f"Committed Redis pipeline of {len(batch_vulnerabilities)} vulnerabilities")
                except Exception as e:
                    logger.error(f"Error executing Redis pipeline: {e}")
                    raise
        
        return total_upserted
    
    async def get_project_mapping(self) -> Dict[str, Dict[str, str]]:
        """
        Get project mapping from Redis.
        Stored as a hash: project_mapping -> {projectid: {appcode, lob}}
        """
        client = await self._get_client()
        mapping = {}
        
        try:
            # Get all hash fields
            raw_mapping = await client.hgetall(self.mapping_key)
            
            for project_id_bytes, data_bytes in raw_mapping.items():
                project_id = project_id_bytes.decode('utf-8')
                data = json.loads(data_bytes.decode('utf-8'))
                
                mapping[project_id] = {
                    'appcode': data.get('appcode', 'unknown'),
                    'lob': data.get('lob', 'unknown')
                }
            
            logger.info(f"Loaded {len(mapping)} project mappings from Redis")
            return mapping
            
        except Exception as e:
            logger.error(f"Error loading project mapping from Redis: {e}")
            return {}
    
    async def set_project_mapping(self, project_id: str, appcode: str, lob: str):
        """Helper method to set project mapping in Redis"""
        client = await self._get_client()
        
        try:
            data = json.dumps({'appcode': appcode, 'lob': lob})
            await client.hset(self.mapping_key, project_id, data)
            logger.info(f"Set project mapping: {project_id} -> {appcode}/{lob}")
            
        except Exception as e:
            logger.error(f"Error setting project mapping: {e}")
    
    async def get_vulnerability(self, finding_id: str) -> Optional[Dict[str, Any]]:
        """Get a single vulnerability by finding ID"""
        client = await self._get_client()
        
        try:
            key = f"{self.key_prefix}{finding_id}"
            value = await client.get(key)
            
            if value:
                return json.loads(value.decode('utf-8'))
            return None
            
        except Exception as e:
            logger.error(f"Error getting vulnerability {finding_id}: {e}")
            return None
    
    async def delete_vulnerability(self, finding_id: str) -> bool:
        """Delete a vulnerability by finding ID"""
        client = await self._get_client()
        
        try:
            key = f"{self.key_prefix}{finding_id}"
            result = await client.delete(key)
            
            if result > 0:
                logger.info(f"Deleted vulnerability: {finding_id}")
                return True
            return False
            
        except Exception as e:
            logger.error(f"Error deleting vulnerability {finding_id}: {e}")
            return False
    
    async def get_statistics(self) -> Dict[str, Any]:
        """Get Redis statistics"""
        client = await self._get_client()
        
        try:
            # Count keys matching pattern
            pattern = f"{self.key_prefix}*"
            cursor = 0
            count = 0
            
            while True:
                cursor, keys = await client.scan(cursor, match=pattern, count=1000)
                count += len(keys)
                
                if cursor == 0:
                    break
            
            # Get Redis info
            info = await client.info('memory')
            
            return {
                'datastore_type': 'redis',
                'key_prefix': self.key_prefix,
                'total_vulnerabilities': count,
                'memory_used_bytes': info.get('used_memory', 0),
                'memory_used_human': info.get('used_memory_human', 'N/A')
            }
            
        except Exception as e:
            logger.error(f"Error getting statistics: {e}")
            return {
                'datastore_type': 'redis',
                'error': str(e)
            }
    
    async def close(self):
        """Close Redis connections"""
        if self.redis_client:
            await self.redis_client.close()
            logger.info("Redis datastore closed")
