"""FastAPI application for querying vulnerability data by appcode and LOB"""

from fastapi import FastAPI, HTTPException, Query
from fastapi.responses import JSONResponse
from typing import List, Dict, Any, Optional
from pydantic import BaseModel, Field
from google.cloud import firestore
import logging
import sys
import os

# Add parent directory to path to import config
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
import config

# Configure logging
logging.basicConfig(level=config.LOG_LEVEL)
logger = logging.getLogger(__name__)

# Initialize FastAPI app
app = FastAPI(
    title="SCC Vulnerability API",
    description="API for querying GCP Security Command Center vulnerability data",
    version="1.0.0"
)

# Initialize Firestore client
vuln_db_name = config.FIRESTORE_VULNERABILITY_DB
if vuln_db_name == '(default)':
    db = firestore.Client(project=config.GCP_PROJECT_ID)
else:
    db = firestore.Client(project=config.GCP_PROJECT_ID, database=vuln_db_name)

vuln_collection = config.FIRESTORE_COLLECTION_VULNERABILITIES

logger.info(f"Initialized Firestore client for database: {vuln_db_name}, collection: {vuln_collection}")


# Pydantic models for response
class CVSSv3(BaseModel):
    base_score: Optional[float] = None
    attack_vector: Optional[str] = None
    attack_complexity: Optional[str] = None
    privileges_required: Optional[str] = None
    user_interaction: Optional[str] = None
    scope: Optional[str] = None
    confidentiality_impact: Optional[str] = None
    integrity_impact: Optional[str] = None
    availability_impact: Optional[str] = None


class Package(BaseModel):
    package_name: Optional[str] = None
    package_type: Optional[str] = None
    package_version: Optional[str] = None
    cpe_uri: Optional[str] = None


class Vulnerability(BaseModel):
    finding_id: str
    finding_name: str
    category: str
    state: str
    severity: str
    description: Optional[str] = None
    resource_name: str
    resource_type: Optional[str] = None
    project_id: Optional[str] = None
    project_display_name: Optional[str] = None
    appcode: Optional[str] = None
    lob: Optional[str] = None
    cve_id: Optional[str] = None
    cvssv3: Optional[CVSSv3] = None
    offending_package: Optional[Package] = None
    fixed_package: Optional[Package] = None
    create_time: Optional[str] = None
    event_time: Optional[str] = None
    age_days: Optional[int] = None
    mute: Optional[str] = None
    external_uri: Optional[str] = None


class PaginationInfo(BaseModel):
    page: int
    page_size: int
    total_results: int
    total_pages: int
    has_next: bool
    has_previous: bool


class VulnerabilityListResponse(BaseModel):
    vulnerabilities: List[Vulnerability]
    pagination: PaginationInfo
    filter_by: str
    filter_value: str


class StatisticsResponse(BaseModel):
    total_vulnerabilities: int
    by_severity: Dict[str, int]
    by_appcode: Dict[str, int]
    by_lob: Dict[str, int]
    by_state: Dict[str, int]


@app.get("/")
async def root():
    """Root endpoint with API information"""
    return {
        "name": "SCC Vulnerability API",
        "version": "1.0.0",
        "endpoints": {
            "/vulnerabilities/by-appcode/{appcode}": "Get vulnerabilities by appcode (paginated)",
            "/vulnerabilities/by-lob/{lob}": "Get vulnerabilities by LOB (paginated)",
            "/vulnerabilities/{finding_id}": "Get a specific vulnerability by finding ID",
            "/statistics": "Get vulnerability statistics",
            "/appcodes": "List all appcodes",
            "/lobs": "List all LOBs",
            "/health": "Health check endpoint"
        }
    }


@app.get("/health")
async def health_check():
    """Health check endpoint"""
    try:
        # Test Firestore connection
        db.collection(vuln_collection).limit(1).get()
        return {"status": "healthy", "database": "connected"}
    except Exception as e:
        logger.error(f"Health check failed: {e}")
        raise HTTPException(status_code=503, detail=f"Database connection failed: {str(e)}")


def paginate_results(docs_list: List[Any], page: int, page_size: int) -> tuple:
    """
    Paginate a list of documents.
    
    Returns:
        Tuple of (paginated_items, pagination_info)
    """
    total_results = len(docs_list)
    total_pages = (total_results + page_size - 1) // page_size  # Ceiling division
    
    start_idx = (page - 1) * page_size
    end_idx = start_idx + page_size
    
    paginated_items = docs_list[start_idx:end_idx]
    
    pagination_info = PaginationInfo(
        page=page,
        page_size=page_size,
        total_results=total_results,
        total_pages=total_pages,
        has_next=page < total_pages,
        has_previous=page > 1
    )
    
    return paginated_items, pagination_info


@app.get("/vulnerabilities/by-appcode/{appcode}", response_model=VulnerabilityListResponse)
async def get_vulnerabilities_by_appcode(
    appcode: str,
    severity: Optional[str] = Query(None, description="Filter by severity (CRITICAL, HIGH, MEDIUM, LOW)"),
    state: Optional[str] = Query(None, description="Filter by state (ACTIVE, INACTIVE)"),
    page: int = Query(1, ge=1, description="Page number (starts from 1)"),
    page_size: int = Query(100, ge=1, le=1000, description="Number of results per page")
):
    """
    Get vulnerabilities filtered by appcode with pagination.
    
    Args:
        appcode: Application code to filter by
        severity: Optional severity filter (CRITICAL, HIGH, MEDIUM, LOW)
        state: Optional state filter (ACTIVE, INACTIVE)
        page: Page number (default: 1)
        page_size: Results per page (default: 100, max: 1000)
    
    Returns:
        Paginated list of vulnerabilities matching the criteria
    """
    try:
        logger.info(f"Querying vulnerabilities for appcode: {appcode}, page: {page}, page_size: {page_size}")
        
        # Build query
        query = db.collection(vuln_collection).where('appcode', '==', appcode)
        
        # Add optional filters
        if severity:
            query = query.where('severity', '==', severity.upper())
        
        if state:
            query = query.where('state', '==', state.upper())
        
        # Execute query - get all results for pagination
        docs = query.stream()
        
        # Convert to list for pagination
        all_vulnerabilities = []
        for doc in docs:
            data = doc.to_dict()
            
            # Convert nested objects
            if data.get('cvssv3'):
                data['cvssv3'] = CVSSv3(**data['cvssv3'])
            if data.get('offending_package'):
                data['offending_package'] = Package(**data['offending_package'])
            if data.get('fixed_package'):
                data['fixed_package'] = Package(**data['fixed_package'])
            
            all_vulnerabilities.append(Vulnerability(**data))
        
        # Paginate results
        paginated_vulns, pagination_info = paginate_results(all_vulnerabilities, page, page_size)
        
        logger.info(f"Found {len(all_vulnerabilities)} total vulnerabilities for appcode: {appcode}, returning page {page}")
        
        return VulnerabilityListResponse(
            vulnerabilities=paginated_vulns,
            pagination=pagination_info,
            filter_by="appcode",
            filter_value=appcode
        )
        
    except Exception as e:
        logger.error(f"Error querying vulnerabilities: {e}")
        raise HTTPException(status_code=500, detail=f"Error querying vulnerabilities: {str(e)}")


@app.get("/vulnerabilities/by-lob/{lob}", response_model=VulnerabilityListResponse)
async def get_vulnerabilities_by_lob(
    lob: str,
    severity: Optional[str] = Query(None, description="Filter by severity (CRITICAL, HIGH, MEDIUM, LOW)"),
    state: Optional[str] = Query(None, description="Filter by state (ACTIVE, INACTIVE)"),
    page: int = Query(1, ge=1, description="Page number (starts from 1)"),
    page_size: int = Query(100, ge=1, le=1000, description="Number of results per page")
):
    """
    Get vulnerabilities filtered by LOB (Line of Business) with pagination.
    
    Args:
        lob: Line of Business to filter by
        severity: Optional severity filter (CRITICAL, HIGH, MEDIUM, LOW)
        state: Optional state filter (ACTIVE, INACTIVE)
        page: Page number (default: 1)
        page_size: Results per page (default: 100, max: 1000)
    
    Returns:
        Paginated list of vulnerabilities matching the criteria
    """
    try:
        logger.info(f"Querying vulnerabilities for LOB: {lob}, page: {page}, page_size: {page_size}")
        
        # Build query
        query = db.collection(vuln_collection).where('lob', '==', lob)
        
        # Add optional filters
        if severity:
            query = query.where('severity', '==', severity.upper())
        
        if state:
            query = query.where('state', '==', state.upper())
        
        # Execute query - get all results for pagination
        docs = query.stream()
        
        # Convert to list for pagination
        all_vulnerabilities = []
        for doc in docs:
            data = doc.to_dict()
            
            # Convert nested objects
            if data.get('cvssv3'):
                data['cvssv3'] = CVSSv3(**data['cvssv3'])
            if data.get('offending_package'):
                data['offending_package'] = Package(**data['offending_package'])
            if data.get('fixed_package'):
                data['fixed_package'] = Package(**data['fixed_package'])
            
            all_vulnerabilities.append(Vulnerability(**data))
        
        # Paginate results
        paginated_vulns, pagination_info = paginate_results(all_vulnerabilities, page, page_size)
        
        logger.info(f"Found {len(all_vulnerabilities)} total vulnerabilities for LOB: {lob}, returning page {page}")
        
        return VulnerabilityListResponse(
            vulnerabilities=paginated_vulns,
            pagination=pagination_info,
            filter_by="lob",
            filter_value=lob
        )
        
    except Exception as e:
        logger.error(f"Error querying vulnerabilities: {e}")
        raise HTTPException(status_code=500, detail=f"Error querying vulnerabilities: {str(e)}")


@app.get("/vulnerabilities/{finding_id}", response_model=Vulnerability)
async def get_vulnerability_by_id(finding_id: str):
    """
    Get a specific vulnerability by finding ID.
    
    Args:
        finding_id: The finding ID to retrieve
    
    Returns:
        Vulnerability details
    """
    try:
        logger.info(f"Querying vulnerability with finding_id: {finding_id}")
        
        doc_ref = db.collection(vuln_collection).document(finding_id)
        doc = doc_ref.get()
        
        if not doc.exists:
            raise HTTPException(status_code=404, detail=f"Vulnerability not found: {finding_id}")
        
        data = doc.to_dict()
        
        # Convert nested objects
        if data.get('cvssv3'):
            data['cvssv3'] = CVSSv3(**data['cvssv3'])
        if data.get('offending_package'):
            data['offending_package'] = Package(**data['offending_package'])
        if data.get('fixed_package'):
            data['fixed_package'] = Package(**data['fixed_package'])
        
        return Vulnerability(**data)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error retrieving vulnerability: {e}")
        raise HTTPException(status_code=500, detail=f"Error retrieving vulnerability: {str(e)}")


@app.get("/statistics", response_model=StatisticsResponse)
async def get_statistics():
    """
    Get vulnerability statistics including counts by severity, appcode, LOB, and state.
    
    Returns:
        Statistics summary
    """
    try:
        logger.info("Calculating vulnerability statistics")
        
        # Get all vulnerabilities (for large datasets, consider aggregation queries)
        docs = db.collection(vuln_collection).stream()
        
        total = 0
        by_severity = {}
        by_appcode = {}
        by_lob = {}
        by_state = {}
        
        for doc in docs:
            data = doc.to_dict()
            total += 1
            
            # Count by severity
            severity = data.get('severity', 'UNKNOWN')
            by_severity[severity] = by_severity.get(severity, 0) + 1
            
            # Count by appcode
            appcode = data.get('appcode', 'unknown')
            by_appcode[appcode] = by_appcode.get(appcode, 0) + 1
            
            # Count by LOB
            lob = data.get('lob', 'unknown')
            by_lob[lob] = by_lob.get(lob, 0) + 1
            
            # Count by state
            state = data.get('state', 'UNKNOWN')
            by_state[state] = by_state.get(state, 0) + 1
        
        logger.info(f"Statistics calculated: {total} total vulnerabilities")
        
        return StatisticsResponse(
            total_vulnerabilities=total,
            by_severity=by_severity,
            by_appcode=by_appcode,
            by_lob=by_lob,
            by_state=by_state
        )
        
    except Exception as e:
        logger.error(f"Error calculating statistics: {e}")
        raise HTTPException(status_code=500, detail=f"Error calculating statistics: {str(e)}")


@app.get("/appcodes")
async def list_appcodes(
    page: int = Query(1, ge=1, description="Page number (starts from 1)"),
    page_size: int = Query(100, ge=1, le=1000, description="Number of results per page")
):
    """
    Get a paginated list of all unique appcodes in the database.
    
    Args:
        page: Page number (default: 1)
        page_size: Results per page (default: 100, max: 1000)
    
    Returns:
        Paginated list of appcodes with their vulnerability counts
    """
    try:
        logger.info(f"Fetching unique appcodes, page: {page}, page_size: {page_size}")
        
        docs = db.collection(vuln_collection).stream()
        
        appcode_counts = {}
        for doc in docs:
            data = doc.to_dict()
            appcode = data.get('appcode', 'unknown')
            appcode_counts[appcode] = appcode_counts.get(appcode, 0) + 1
        
        # Sort by count descending
        sorted_appcodes = sorted(appcode_counts.items(), key=lambda x: x[1], reverse=True)
        
        # Convert to list of dicts
        all_appcodes = [
            {"appcode": appcode, "vulnerability_count": count}
            for appcode, count in sorted_appcodes
        ]
        
        # Paginate
        paginated_appcodes, pagination_info = paginate_results(all_appcodes, page, page_size)
        
        return {
            "total_appcodes": len(all_appcodes),
            "appcodes": paginated_appcodes,
            "pagination": pagination_info
        }
        
    except Exception as e:
        logger.error(f"Error fetching appcodes: {e}")
        raise HTTPException(status_code=500, detail=f"Error fetching appcodes: {str(e)}")


@app.get("/lobs")
async def list_lobs(
    page: int = Query(1, ge=1, description="Page number (starts from 1)"),
    page_size: int = Query(100, ge=1, le=1000, description="Number of results per page")
):
    """
    Get a paginated list of all unique LOBs (Lines of Business) in the database.
    
    Args:
        page: Page number (default: 1)
        page_size: Results per page (default: 100, max: 1000)
    
    Returns:
        Paginated list of LOBs with their vulnerability counts
    """
    try:
        logger.info(f"Fetching unique LOBs, page: {page}, page_size: {page_size}")
        
        docs = db.collection(vuln_collection).stream()
        
        lob_counts = {}
        for doc in docs:
            data = doc.to_dict()
            lob = data.get('lob', 'unknown')
            lob_counts[lob] = lob_counts.get(lob, 0) + 1
        
        # Sort by count descending
        sorted_lobs = sorted(lob_counts.items(), key=lambda x: x[1], reverse=True)
        
        # Convert to list of dicts
        all_lobs = [
            {"lob": lob, "vulnerability_count": count}
            for lob, count in sorted_lobs
        ]
        
        # Paginate
        paginated_lobs, pagination_info = paginate_results(all_lobs, page, page_size)
        
        return {
            "total_lobs": len(all_lobs),
            "lobs": paginated_lobs,
            "pagination": pagination_info
        }
        
    except Exception as e:
        logger.error(f"Error fetching LOBs: {e}")
        raise HTTPException(status_code=500, detail=f"Error fetching LOBs: {str(e)}")


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
